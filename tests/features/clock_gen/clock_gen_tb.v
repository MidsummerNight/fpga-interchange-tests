// Copyright (C) 2021  The Symbiflow Authors.
//
// Use of this source code is governed by a ISC-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/ISC
//
// SPDX-License-Identifier: ISC

`timescale 1 ns / 1 ps
`default_nettype none

module tb;

`include "utils.v"

parameter CLK_PULSE = 5;

// Time to power up the PLL and MMCM.
// These values were calculated from the test results
// and are necessary to synchonize the clocks generated by the
// DUTs and the ones used to simulate the testbench counters.
parameter PLL_WAIT_PWRUP = 405;
parameter MMCM_WAIT_PWRUP = 385;

// Custom time when PLL is powered up
parameter PWRUP = CLK_PULSE * 4;

reg clk_in;
reg [3:0] pll_clk_out, mmcm_clk_out;
reg pwrdwn, rst;

always #CLK_PULSE clk_in <= !clk_in;

initial begin
    clk_in = 1'b0;
    pll_clk_out = 8'b0;
    mmcm_clk_out = 8'b0;
    rst = 1'b1;
    pwrdwn = 1'b1;

    $dumpfile(`STRINGIFY(`VCD));
    $dumpvars;

    #(CLK_PULSE * 2) rst = 1'b0;
    #PWRUP pwrdwn = 1'b0;

    #2000 $finish();
end

// Synchronize the clocks from the PLL.
// Each consequent clock is divided by a factor of 2
initial begin
    #(PLL_WAIT_PWRUP + PWRUP - CLK_PULSE);
    forever #CLK_PULSE pll_clk_out[0] = !pll_clk_out[0];
end

initial begin
    #(PLL_WAIT_PWRUP + PWRUP - CLK_PULSE * 2);
    forever #(CLK_PULSE * 2) pll_clk_out[1] = !pll_clk_out[1];
end

initial begin
    #(PLL_WAIT_PWRUP + PWRUP - CLK_PULSE * 4);
    forever #(CLK_PULSE * 4) pll_clk_out[2] = !pll_clk_out[2];
end

initial begin
    #(PLL_WAIT_PWRUP + PWRUP - CLK_PULSE * 8);
    forever #(CLK_PULSE * 8) pll_clk_out[3] = !pll_clk_out[3];
end

// Synchronize the clocks from the MMCM
// Each consequent clock is divided by a factor of 2
initial begin
    #(MMCM_WAIT_PWRUP + PWRUP - CLK_PULSE);
    forever #CLK_PULSE mmcm_clk_out[0] = !mmcm_clk_out[0];
end

initial begin
    #(MMCM_WAIT_PWRUP + PWRUP - CLK_PULSE * 2);
    forever #(CLK_PULSE * 2) mmcm_clk_out[1] = !mmcm_clk_out[1];
end

initial begin
    #(MMCM_WAIT_PWRUP + PWRUP - CLK_PULSE * 4);
    forever #(CLK_PULSE * 4) mmcm_clk_out[2] = !mmcm_clk_out[2];
end

initial begin
    #(MMCM_WAIT_PWRUP + PWRUP - CLK_PULSE * 8);
    forever #(CLK_PULSE * 8) mmcm_clk_out[3] = !mmcm_clk_out[3];
end

wire [9:0] out;
top dut (
    .clk(clk_in),
    .sw({pwrdwn, rst}),
    .led(out)
);

genvar i;
generate for (i=0; i<4; i=i+1) begin
    reg [3:0] counter_pll;
    reg [3:0] counter_mmcm;

    // PLL
    always @(posedge pll_clk_out[i] or posedge out[8]) begin
        if (!out[8])
            counter_pll <= 0;
        else
            counter_pll <= counter_pll + 1;

        assert(out[i] == counter_pll[3], out[i]);
    end

    // MMCM
    reg start = 1'b1;
    always @(posedge mmcm_clk_out[i] or posedge out[9]) begin
        if (!out[9])
            counter_mmcm <= 0;
        else if (out[9] && start) begin
            // The counters in the MMCM test seem to be delayed by one clock cycle
            // even though the LOCKED signal is active a clock pulse earlier.
            // This step aligns the first counter iterations.
            counter_mmcm <= 0;
            start <= 0;
        end else
            counter_mmcm <= counter_mmcm + 1;

        assert(out[i + 4] == counter_mmcm[3], out[i + 4]);
    end

end endgenerate

endmodule
